#pragma config(Hubs,  S1, HTServo,  none,     none,     none)
#pragma config(Hubs,  S3, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     touchSensor,    sensorTouch)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S3_C1_1,      ,             tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,      ,             tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float encToCm = 4.1/360;
const float length = 18;

const short lrServo = servo1;
const short udServo = servo2;

const float width = 15;
const float height = 20;

const float dx = -2;
const float dy = 2.5;

const float imWidth = 480;
const float imHeigth = 640;

const short upAngle = 180;
const short downAngle = 217;

int encPos = 0;

// 0 - move on, 1 - moving to berry, 2 - grabbed

short state = 0;

bool flag = false;

float x = 0, y = 0;
float xcm = x/imWidth*width, ycm = y/imHeigth*height;

float x0 = 0;

float phi = 3/4, alpha = 0.5;
float r = 0;

float a = 0.5, b = 1.3;
ubyte data[10];

int last = -1;
bool stateChangeHandled[] = {false, false, false};

void grab() {
	motor[motorE] = 50;
	motor[motorD] = 0;
	for (int i = servo[servo2]; i <= downAngle; i++) {
			servo[servo2] = i;
			wait10Msec(5);
	}
	wait10Msec(200);

	motor[motorE] = 0;
	motor[motorD] = 50;

	wait10Msec(100);

	for (int i = servo[servo2]; i >= upAngle; i--) {
			servo[servo2] = i;
			wait10Msec(5);
	}
}

task support(){
	for(;;) {
		motor[motorD] = 50;
		wait1Msec(450);
		motor[motorD] = 0;
		wait1Msec(80);
	}

}

void deliver() {
	int target = -(int)(70/encToCm);
	startTask(support);
	motor[motorA] = -40;
	servo[servo1] = 100;
	nMotorEncoder[motorA] = encPos;
	while(nMotorEncoder[motorA] > target) {
			wait1Msec(5);
	}
	motor[motorA] = 0;
	for (int i = servo[servo2]; i <= downAngle - 10; i++) {
			servo[servo2] = i;
			wait10Msec(5);
	}
	stopTask(support);
	motor[motorE] = 50;
	motor[motorD] = 0;

	wait1Msec(1250);

	motor[motorA] = 0;
	for (int i = servo[servo2]; i >= upAngle; i--) {
			servo[servo2] = i;
			wait10Msec(5);
	}
}


float getDeltaX() {
	float delta = sqrt(length*length - ycm*ycm);
	return (delta);

}

short getRotAngle()
{
	float c = ycm/length;
	return((short)(acos(c)/PI*255));
}


task btcom()
{

		long x0, y0, z;
  string displayx, displayy, displayz;
	while(true) {

		x0 = messageParm[0];
    y0 = messageParm[1];
    z = messageParm[2];



    if (nMotorEncoder[motorA] <= -4*360 - 270) {
    	flag = true;
    }

    if (flag && y == 0) {
    	x = x0;
    	y = y0;
    }

    //Formats the variables into a 'Value x: ' format and displays each on a seperate line
    stringFormat(displayx, "Value x: %d", x);
    stringFormat(displayy, "Value y: %d", y);
    stringFormat(displayz, "Value z: %d", z);

   /* displayCenteredTextLine(0, displayx);
    displayCenteredTextLine(2, displayy);
    displayCenteredTextLine(4, displayz);*/

    //Waits 300 milliseconds, clears the screen, and loops again
    wait1Msec(100);
    ClearMessage();
	}
}

task main()
{
	servo[servo1] = 128;
	servo[servo2] = upAngle;
	motor[motorA] = 50;

//nMotorEncoder

 	while(SensorValue(touchSensor) == 0)  // while the Touch Sensor is inactive (hasn't been pressed):
	  {
	    wait1Msec(1);
	  }
  while(SensorValue(touchSensor) == 1)  // while the Touch Sensor is active (pressed):
	  {
	    motor[motorA] = -50;
	  }
	 	encPos += nMotorEncoder[motorA];
		nMotorEncoder[motorA] = 0;
	 playSound(soundBeepBeep);
	startTask(btcom);
	encPos += nMotorEncoder[motorA];
	nMotorEncoder[motorA] = 0;

	while (1) {
	if (x > 0) {


		playSound(soundBlip);
	if (x < 240) {

	xcm = x/imWidth*width*a;

}else {
xcm = 240/imWidth*width*a + (x-240)/imWidth*width*b;
}
if (y < 320){
	ycm = y/imHeigth*height*a;
}
else
{
	ycm = 320/imHeigth*height*a + (320-y)/imHeigth*height*b;
}

	xcm += dx;
	ycm += dy;

	motor[motorA] = 0;

	float delta = getDeltaX();
	nxtdisplayString(0, "%d %d", xcm, ycm);

	if (delta > xcm) {
		float ddelta = (delta - xcm);
		nxtdisplayString(0, "%f %f",xcm, ycm);
		motor[motorA] = 20;
		encPos += nMotorEncoder[motorA];
		nMotorEncoder[motorA] = 0;
		while(nMotorEncoder[motorA] < (int)(ddelta/encToCm)) {
			wait1Msec(5);
		}
		motor[motorA] = 0;
	}

	else if (delta < xcm) {
		float ddelta = xcm - delta;

		motor[motorA] = -20;
		encPos += nMotorEncoder[motorA];
		nMotorEncoder[motorA] = 0;
		while(nMotorEncoder[motorA] < (int)(ddelta/encToCm)) {
			wait1Msec(5);
		}
		motor[motorA] = 0;
	}


	int ra = getRotAngle();
	int s = servo[servo1];

	if (ra > s) {

	for (int i = s; i <= ra; i++) {
			servo[servo1] = i;
			wait10Msec(5);
	}

}

else {
	for (int i = s; i >= ra; i--) {
			servo[servo1] = i;
			wait10Msec(5);
	}

}
flag = true;
break;

}
}
if (flag)
{

	grab();
	deliver();

}

}
